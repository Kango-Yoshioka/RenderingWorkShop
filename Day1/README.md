_# レンダラー実装編 #1
今回からシンプルなレンダラーを実装していきます。
目標はこんな感じのシーンを表現します。

![sample.png](sample.png)

# 今回の実装目標

今回はここまでを目標にします。

![sample_image.png](sample_image.png)

## 実装すること

実装するのは大きく分けて以下の３つです。

* Renderer
* Image
* Body

# 各クラスについて

## Renderer

このクラスはレンダリングを担当するクラスです。カメラやシーン内に存在するオブジェクト（Body）を管理しています。

## Image

このクラスは画像データを管理するクラスです。

## Body

このクラスはシーン上に設置するオブジェクトのクラスです。
形状（球）や色を持っています。

# レンダリングの大まかな流れ

1. カメラ、フィルム、オブジェクトをシーン内に設置する
2. カメラからフィルムの各ピクセルに向けてレイを飛ばし、輝度の計算をする
3. Imageクラスに計算した輝度を記録し、出力する

以上の流れを簡単な疑似コードにすると以下のようになります。
（実際の実装とは異なります。）

```C++
Image Render() {
    /// カメラやオブジェクトをシーン内に設置する
    renderingPrepare();
    /// 出力用のImageを用意
    Image image;
    /// フィルム上のピクセル全てに向けてレイを飛ばす
    for(imageの全てのピクセル) {
        Ray = カメラからピクセルの中心に向けたRay;
        if(Rayがオブジェクトと衝突したか) {
            /// オブジェクトに当たった場合
            ピクセルの色 = 衝突したオブジェクトの色;
        } else {
            /// オブジェクトに当たらなかった場合
            ピクセルの色 = 背景色;
        }
    }
  
    return image;
}
```

# レイとオブジェクトの衝突判定

今回の肝となる衝突判定について見ていきましょう。
オブジェクトの形状には三角形、四角形などがありますが、この勉強会では比較的簡単に実装できる球を扱っていきます。

## レイの定義

レイは以下の式で表現されます。

$$
\bm{P}(t)=\bm{o}+t\bm{d}
$$

ここで$\bm{o}$はレイの原点で、$\bm{d}$は方向を表すベクトルです。使いやすくするために長さは0になるように正規化します。

$t$はレイの長さを表すスカラーとなります。実用上ではオブジェクトとレイの衝突距離が主な使用用途となります。

## 球の定義

球は以下の式で表現されます。

$$
(P_x-C_x)^2+(P_y-C_y)^2+(P_z-Cz)^2=R^2
$$

ここで$\bm P$はある点を表し、$\bm C$は半径$R$の球の中心を示しています。

もし点$\bm P$が球上にあるならこの式が成立します。もうすこし簡単に表記するために内積を使用します。

球の中心$\bm{C}$から点$\bm P$までへのベクトルは$(\bm P-\bm C)$で表現できるので、

$$
(\bm P-\bm C)\cdot(\bm P-\bm C)=(P_x-C_x)^2+(P_y-C_y)^2+(P_z-Cz)^2
$$

となります。したがってベクトルを用いた球の方程式は

$$
(\bm P-\bm C)\cdot(\bm P-\bm C)=R^2
$$

となります。

## レイと球の衝突判定

レイと球の衝突判定をするにはレイと球
